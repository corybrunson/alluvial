open = FALSE, col = p$col[i], border = p$border[i])
}
}
for(k in seq_along(ax))
{
text( j, mean(ax[[k]]), labels=names(ax)[k])
}
}
# X axis
axis(1, at= rep(c(-cw, cw), ncol(d)) + rep(seq_along(d), each=2),
line=0.5, col="white", col.ticks="black", labels=FALSE)
axis(1, at=seq_along(d), tick=FALSE, labels=names(d))
par(op)
}
alluvial( tit[,1:4], freq=tit$Freq, border=NA,
col=ifelse( tit$Class == "3rd" & tit$Sex == "Male", "red", "gray") )
alluvial( tit[,1:4], freq=tit$Freq, border=NA )
library(devtools)
install.packages("devtools")
library(devtools)
load_all()
install.packages("roxygen")
install.packages("roxygen2")
load_all()
tit <- as.data.frame(Titanic)
tit2d <- aggregate( Freq ~ Class + Survived, data=tit, sum)
alluvial( tit2d[,1:2], freq=tit2d$Freq, xw=0.0, alpha=0.8,
gap.width=0.1, col= "steelblue", border="white",
layer = tit2d$Survived != "Yes" )
alluvial( tit2d[,1:2], freq=tit2d$Freq,
hide=tit2d$Freq < 150,
xw=0.0, alpha=0.8,
gap.width=0.1, col= "steelblue", border="white",
layer = tit2d$Survived != "Yes" )
# 3d
tit3d <- aggregate( Freq ~ Class + Sex + Survived, data=tit, sum)
alluvial(tit3d[,1:3], freq=tit3d$Freq, alpha=1, xw=0.2,
col=ifelse( tit3d$Survived == "No", "red", "gray"),
layer = tit3d$Sex != "Female",
border="white")
# 4d
alluvial( tit[,1:4], freq=tit$Freq, border=NA,
hide = tit$Freq < quantile(tit$Freq, .50),
col=ifelse( tit$Class == "3rd" & tit$Sex == "Male", "red", "gray") )
# 3d example with custom ordering
# Reorder "Sex" axis according to survival status
ord <- list(NULL, with(tit3d, order(Sex, Survived)), NULL)
alluvial(tit3d[,1:3], freq=tit3d$Freq, alpha=1, xw=0.2,
col=ifelse( tit3d$Survived == "No", "red", "gray"),
layer = tit3d$Sex != "Female",
border="white", ordering=ord)
alluvial( tit[,1:4], freq=tit$Freq, border=NA )
freq=tit$Freq
border=NA
col="gray"
hide=FALSE
alpha=0.5
gap.width=0.05
xw=0.1
cw=0.1
p <- data.frame( ..., freq=freq, col, alpha, border, hide, stringsAsFactors=FALSE)
p <- data.frame( tit[,1:4], freq=freq, col, alpha, border, hide, stringsAsFactors=FALSE)
np <- ncol(p) - 5                    # Number of dimensions
n <- nrow(p)
layer <- 1:n
p$layer <- layer
d <- p[ , 1:np, drop=FALSE]          # Dimensions dframe
p <- p[ , -c(1:np), drop=FALSE]      # Parameteres dframe
p$freq <- with(p, freq/sum(freq))    # Frequencies (weights)
p
col <- col2rgb(p$col, alpha=TRUE)
if(!identical(alpha, FALSE)) {
col["alpha", ] <- p$alpha*256
}
p$col <- apply(col, 2, function(x) do.call(rgb, c(as.list(x), maxColorValue = 256)))
isch <- sapply(d, is.character)
d[isch] <- lapply(d[isch], as.factor)
i=1
f=p$freq
w=gap.width
a <- c(i, (1:ncol(d))[-i])
a
do.call(order, d[a])
do.call(order, d[4:1])
head(d)
o <- do.call(order, d[a])
o
d2 <- d
d2
d2[1]
ordering[[i]]
ord <- list(NULL, with(tit3d, order(Sex, Survived)), NULL)
ordering=ord
ordering[[i]]
ordering
stopifnot(is.list(ordering))
if( length(ordering) != np )
stop("'ordering' argument should have ",
np, " components, has ", length(ordering))
ord <- list(NULL, with(tit3d, order(Sex, Survived)), NULL, NULL)
if( length(ordering) != np )
stop("'ordering' argument should have ",
np, " components, has ", length(ordering))
ordering=ord
if( length(ordering) != np )
stop("'ordering' argument should have ",
np, " components, has ", length(ordering))
d2[1] <- ordering[[i]]
d2
do.call(order, d2[a])
a
d2
d2 <- d
which(!is.null(ordering))
ordering
which(sapply(ordering, is.null))
i=2
a <- c(i, (1:ncol(d))[-i])
a
do.call(order, d[a])
d2 <- d
ordering[[i]]
d2[1]
d2[1] <- ordering[[i]]
d2
o <- do.call(order, d2[a])
o
do.call(order, d[a])
with(tit, order(Sex, Survived))
ord <- list(NULL, with(tit, order(Sex, Survived)),
NULL, with(tit, order(Sex, Survived)))
dim(tit)
tit
alluvial( tit[,1:4], freq=tit$Freq, border=NA )
alluvial( tit[,1:4], freq=tit$Freq, border=NA )
alluvial( tit[,1:4], freq=tit$Freq, border=NA, ordering=ord )
list(a=1:5,b=6:10)["c"]
is.null(list(a=1:5,b=6:10)["c"])
is.na(list(a=1:5,b=6:10)["c"])
list(a=1:5,b=6:10)["a"]
length(list(a=1:5,b=6:10)["a"])
list(a=1:5,b=6:10)[["a"]]
list(a=1:5,b=6:10)[["c"]]
is.null(list(a=1:5,b=6:10)[["c"]])
rank.pillars="leftward"
# Given a range 1:n and a starting index i,
# list the indices "zigzagging out" from i to the bounds
zzout <- function(n, i) {
if(!(i %in% 1:n)) stop('the given index lies outside the range')
# Radii
r1 <- i - 1
r2 <- n - i
r <- min(r1, r2)
# Unless prespecified, attempt cohesion in the direction of the closer end
leftward <- (i <= n / 2)
# Setup
sgn <- if(r1 == r2) 0 else (r2 - r1) / abs(r2 - r1)
rem <- (i + sgn * (r + 1)):((n+1)/2 + sgn * (n-1)/2)
zz <- (1 - 2 * leftward) * c(1, -1)
# Order
c(i,
if(r == 0) c() else sapply(1:r, function(j) i + j * zz),
if(sgn == 0) c() else rem)
}
rank.fun <- list(
leftward = function(n, i) c(i, (1:n)[-i]),
rightward = function(n, i) c(i, (n:1)[-i]),
zzout = zzout
)[[rank.pillars]]
rank.fun
a
a <- if( is.null(rank.fun) ) 1:ncol(d) else rank.fun(n = ncol(d), i = i)
a
rank.pillars="rightward"
rank.fun <- list(
leftward = function(n, i) c(i, (1:n)[-i]),
rightward = function(n, i) c(i, (n:1)[-i]),
zzout = zzout
)[[rank.pillars]]
a <- if( is.null(rank.fun) ) 1:ncol(d) else rank.fun(n = ncol(d), i = i)
a
(5:1)[-(5-2)]
(5:1)[-(6-2)]
rank.pillars="rightward"
rank.fun <- list(
leftward = function(n, i) c(i, (1:n)[-i]),
rightward = function(n, i) c(i, (n:1)[-(n+1-i)]),
zzout = zzout
)[[rank.pillars]]
a <- if( is.null(rank.fun) ) 1:ncol(d) else rank.fun(n = ncol(d), i = i)
a
rank.pillars="zzout"
rank.fun <- list(
leftward = function(n, i) c(i, (1:n)[-i]),
rightward = function(n, i) c(i, (n:1)[-(n+1-i)]),
zzout = zzout
)[[rank.pillars]]
a <- if( is.null(rank.fun) ) 1:ncol(d) else rank.fun(n = ncol(d), i = i)
a
#' Alluvial diagram
#'
#' Drawing alluvial diagrams also known as parallel set plots.
#'
#' Still under development!
#'
#' @param ... vectors or data frames, all for the same number of observations
#' @param freq numeric, vector of frequencies of the same length as the number of observations
#' @param col vector of colors of the stripes
#' @param border vector of border colors for the stripes
#' @param layer numeric, order of drawing of the stripes
#' @param hide logical, should particular stripe be plotted
#' @param alpha numeric, vector of transparency of the stripes
#' @param gap.width numeric, relative width of inter-category gaps
#' @param xw numeric, the distance from the set axis to the control points of the xspline
#' @param cw numeric, width of the category axis
#'
#' @return Nothing
#'
#' @export
#'
#' @example examples/alluvial.R
alluvial <- function( ..., freq, col="gray", border=0, layer, hide=FALSE, alpha=0.5,
gap.width=0.05, xw=0.1, cw=0.1, rank.pillars="leftward", ordering=NULL)
{
# Data and graphical parameters
p <- data.frame( ..., freq=freq, col, alpha, border, hide, stringsAsFactors=FALSE)
np <- ncol(p) - 5                    # Number of dimensions
# select ranking function
rank.fun <- list(
leftward = function(n, i) c(i, (1:n)[-i]),
rightward = function(n, i) c(i, (n:1)[-(n+1-i)]),
zzout = zzout
)[[rank.pillars]]
# check if 'ordering' is of proper form
if( !is.null(ordering) )
{
stopifnot(is.list(ordering))
if( length(ordering) != np )
stop("'ordering' argument should have ",
np, " components, has ", length(ordering))
}
n <- nrow(p)
# Layers determine plotting order
if(missing(layer))
{
layer <- 1:n
}
p$layer <- layer
d <- p[ , 1:np, drop=FALSE]          # Dimensions dframe
p <- p[ , -c(1:np), drop=FALSE]      # Parameteres dframe
p$freq <- with(p, freq/sum(freq))    # Frequencies (weights)
# Converting colors to hexcodes
col <- col2rgb(p$col, alpha=TRUE)
if(!identical(alpha, FALSE)) {
col["alpha", ] <- p$alpha*256
}
p$col <- apply(col, 2, function(x) do.call(rgb, c(as.list(x), maxColorValue = 256)))
# convert character vectors in data to factors
isch <- sapply(d, is.character)
d[isch] <- lapply(d[isch], as.factor)
# Compute endpoints of flows (polygons)
# i = dimension id
# d = data frame of dimensions
# f = weights
# w = gap between categories
getp <- function(i, d, f, w=gap.width) {
# Ordering dimension ids for lexicographic sorting
a <- if( is.null(rank.fun) ) 1:ncol(d) else rank.fun(n = ncol(d), i = i)
#a <- c(i, (1:ncol(d))[-i])
# Order of rows of d starting from i-th dimension
if( is.null(ordering[[i]]) )
{
o <- do.call(order, d[a])
} else {
d2 <- d
d2[1] <- ordering[[i]]
o <- do.call(order, d2[a])
}
# Breakpoints on a dimension
x <- c(0, cumsum(f[o])) * (1-w)
# Stripe coordinates on a dimension
x <- cbind(x[-length(x)], x[-1])
# By how much stripes need to be shifted upwards (gap/max(gap))
gap <- cumsum( c(0L, diff(as.numeric(d[o,i])) != 0) )
mx <- max(gap)
if (mx == 0) mx <- 1
# shifts
gap <- gap / mx * w
# add gap-related shifts to stripe coordinates on dimension i
(x + gap)[order(o),]
}
# Calculate stripe locations on dimensions: list of data frames. A component
# for a dimension. Data frame contains 'y' locations of stripes.
dd <- lapply(seq_along(d), getp, d=d, f=p$freq)
rval <- list( endpoints=dd )
# Plotting
op <- par(mar=c(2, 1, 1, 1))
plot(NULL, type="n", xlim=c(1-cw, np+cw), ylim=c(0, 1), xaxt="n", yaxt="n",
xaxs="i", yaxs="i", xlab='', ylab='', frame=FALSE)
# For every stripe
ind <- rev(order(p$layer)[!hide])
for(i in ind )
{
# For every inter-dimensional segment
for(j in 1:(np-1) )
{
# Draw stripe
xspline( c(j, j, j+xw, j+1-xw, j+1, j+1, j+1-xw, j+xw, j) + rep(c(cw, -cw, cw), c(3, 4, 2)),
c( dd[[j]][i, c(1, 2, 2)], rev(dd[[j+1]][i, c(1, 1, 2, 2)]), dd[[j]][i,c(1, 1)]),
shape = c(0,0,1,1,0,0,1,1,0, 0),
open=FALSE,
col=p$col[i], border=p$border[i])
}
}
# Category blocks with labels
for(j in seq_along(dd))
{
ax <- lapply(split(dd[[j]], d[,j]), range)
for(k in seq_along(ax))
{
rect( j-cw, ax[[k]][1], j+cw, ax[[k]][2] )
text( j, mean(ax[[k]]), labels=names(ax)[k])
}
}
# X axis
axis(1, at= rep(c(-cw, cw), ncol(d)) + rep(seq_along(d), each=2),
line=0.5, col="white", col.ticks="black", labels=FALSE)
axis(1, at=seq_along(d), tick=FALSE, labels=names(d))
par(op)
return(rval)
}
alluvial( tit[,1:4], freq=tit$Freq, border=NA )
alluvial( tit[,1:4], freq=tit$Freq, border=NA, ordering=ord )
alluvial( tit[,1:4], freq=tit$Freq, border=NA, ordering="zzout" )
alluvial( tit[,1:4], freq=tit$Freq, border=NA, rank.pillars="zzout" )
alluvial( tit[,1:4], freq=tit$Freq, border=NA, rank.pillars="rightward" )
alluvial( tit[,1:4], freq=tit$Freq, border=NA, rank.pillars="leftward" )
#' Alluvial diagram
#'
#' Drawing alluvial diagrams also known as parallel set plots.
#'
#' Still under development!
#'
#' @param ... vectors or data frames, all for the same number of observations
#' @param freq numeric, vector of frequencies of the same length as the number of observations
#' @param col vector of colors of the stripes
#' @param border vector of border colors for the stripes
#' @param layer numeric, order of drawing of the stripes
#' @param hide logical, should particular stripe be plotted
#' @param alpha numeric, vector of transparency of the stripes
#' @param gap.width numeric, relative width of inter-category gaps
#' @param xw numeric, the distance from the set axis to the control points of the xspline
#' @param cw numeric, width of the category axis
#'
#' @return Nothing
#'
#' @export
#'
#' @example examples/alluvial.R
alluvial <- function( ..., freq, col="gray", border=0, layer, hide=FALSE, alpha=0.5,
gap.width=0.05, xw=0.1, cw=0.1, rank.pillars="rightward", ordering=NULL)
{
# Data and graphical parameters
p <- data.frame( ..., freq=freq, col, alpha, border, hide, stringsAsFactors=FALSE)
np <- ncol(p) - 5                    # Number of dimensions
# select ranking function
rank.fun <- list(
rightward = function(n, i) c(i, (1:n)[-i]),
leftward = function(n, i) c(i, (n:1)[-(n+1-i)]),
zzout = zzout
)[[rank.pillars]]
# check if 'ordering' is of proper form
if( !is.null(ordering) )
{
stopifnot(is.list(ordering))
if( length(ordering) != np )
stop("'ordering' argument should have ",
np, " components, has ", length(ordering))
}
n <- nrow(p)
# Layers determine plotting order
if(missing(layer))
{
layer <- 1:n
}
p$layer <- layer
d <- p[ , 1:np, drop=FALSE]          # Dimensions dframe
p <- p[ , -c(1:np), drop=FALSE]      # Parameteres dframe
p$freq <- with(p, freq/sum(freq))    # Frequencies (weights)
# Converting colors to hexcodes
col <- col2rgb(p$col, alpha=TRUE)
if(!identical(alpha, FALSE)) {
col["alpha", ] <- p$alpha*256
}
p$col <- apply(col, 2, function(x) do.call(rgb, c(as.list(x), maxColorValue = 256)))
# convert character vectors in data to factors
isch <- sapply(d, is.character)
d[isch] <- lapply(d[isch], as.factor)
# Compute endpoints of flows (polygons)
# i = dimension id
# d = data frame of dimensions
# f = weights
# w = gap between categories
getp <- function(i, d, f, w=gap.width) {
# Ordering dimension ids for lexicographic sorting
a <- if( is.null(rank.fun) ) 1:ncol(d) else rank.fun(n = ncol(d), i = i)
#a <- c(i, (1:ncol(d))[-i])
# Order of rows of d starting from i-th dimension
if( is.null(ordering[[i]]) )
{
o <- do.call(order, d[a])
} else {
d2 <- d
d2[1] <- ordering[[i]]
o <- do.call(order, d2[a])
}
# Breakpoints on a dimension
x <- c(0, cumsum(f[o])) * (1-w)
# Stripe coordinates on a dimension
x <- cbind(x[-length(x)], x[-1])
# By how much stripes need to be shifted upwards (gap/max(gap))
gap <- cumsum( c(0L, diff(as.numeric(d[o,i])) != 0) )
mx <- max(gap)
if (mx == 0) mx <- 1
# shifts
gap <- gap / mx * w
# add gap-related shifts to stripe coordinates on dimension i
(x + gap)[order(o),]
}
# Calculate stripe locations on dimensions: list of data frames. A component
# for a dimension. Data frame contains 'y' locations of stripes.
dd <- lapply(seq_along(d), getp, d=d, f=p$freq)
rval <- list( endpoints=dd )
# Plotting
op <- par(mar=c(2, 1, 1, 1))
plot(NULL, type="n", xlim=c(1-cw, np+cw), ylim=c(0, 1), xaxt="n", yaxt="n",
xaxs="i", yaxs="i", xlab='', ylab='', frame=FALSE)
# For every stripe
ind <- rev(order(p$layer)[!hide])
for(i in ind )
{
# For every inter-dimensional segment
for(j in 1:(np-1) )
{
# Draw stripe
xspline( c(j, j, j+xw, j+1-xw, j+1, j+1, j+1-xw, j+xw, j) + rep(c(cw, -cw, cw), c(3, 4, 2)),
c( dd[[j]][i, c(1, 2, 2)], rev(dd[[j+1]][i, c(1, 1, 2, 2)]), dd[[j]][i,c(1, 1)]),
shape = c(0,0,1,1,0,0,1,1,0, 0),
open=FALSE,
col=p$col[i], border=p$border[i])
}
}
# Category blocks with labels
for(j in seq_along(dd))
{
ax <- lapply(split(dd[[j]], d[,j]), range)
for(k in seq_along(ax))
{
rect( j-cw, ax[[k]][1], j+cw, ax[[k]][2] )
text( j, mean(ax[[k]]), labels=names(ax)[k])
}
}
# X axis
axis(1, at= rep(c(-cw, cw), ncol(d)) + rep(seq_along(d), each=2),
line=0.5, col="white", col.ticks="black", labels=FALSE)
axis(1, at=seq_along(d), tick=FALSE, labels=names(d))
par(op)
return(rval)
}
alluvial( tit[,1:4], freq=tit$Freq, border=NA, rank.pillars="rightward" )
alluvial( tit[,1:4], freq=tit$Freq, border=NA, rank.pillars="leftward" )
alluvial( tit[,1:4], freq=tit$Freq, border=NA, rank.pillars="zzout" )
ord <- list(NULL, with(tit3d, order(Sex, Survived)),
NULL, with(tit3d, order(Sex, Survived)))
alluvial( tit[,1:4], freq=tit$Freq, border=NA,
rank.pillars="rightward" )
alluvial( tit[,1:4], freq=tit$Freq, border=NA,
rank.pillars="rightward", ordering=ord )
alluvial( tit[,1:4], freq=tit$Freq, border=NA,
rank.pillars="zzout" )
alluvial( tit[,1:4], freq=tit$Freq, border=NA,
rank.pillars="zzout", ordering=ord )
ord <- list(NULL, with(tit, order(Sex, Survived)),
NULL, with(tit, order(Sex, Survived)))
alluvial( tit[,1:4], freq=tit$Freq, border=NA,
rank.pillars="rightward" )
alluvial( tit[,1:4], freq=tit$Freq, border=NA,
rank.pillars="rightward", ordering=ord )
alluvial( tit[,1:4], freq=tit$Freq, border=NA,
rank.pillars="zzout" )
alluvial( tit[,1:4], freq=tit$Freq, border=NA,
rank.pillars="zzout", ordering=ord )
ord <- list(NULL, with(tit, order(Sex, Survived)),
NULL, with(tit, order(Sex, Age)))
alluvial( tit[,1:4], freq=tit$Freq, border=NA,
rank.pillars="rightward" )
alluvial( tit[,1:4], freq=tit$Freq, border=NA,
rank.pillars="rightward", ordering=ord )
alluvial( tit[,1:4], freq=tit$Freq, border=NA,
rank.pillars="zzout" )
alluvial( tit[,1:4], freq=tit$Freq, border=NA,
rank.pillars="zzout", ordering=ord )
ord <- list(NULL, with(tit, order(Sex, Survived)),
NULL, with(tit, order(Age)))
alluvial( tit[,1:4], freq=tit$Freq, border=NA,
rank.pillars="rightward" )
alluvial( tit[,1:4], freq=tit$Freq, border=NA,
rank.pillars="rightward", ordering=ord )
alluvial( tit[,1:4], freq=tit$Freq, border=NA,
rank.pillars="zzout" )
alluvial( tit[,1:4], freq=tit$Freq, border=NA,
rank.pillars="zzout", ordering=ord )
