if(FALSE)
{
5
} else
{
7
}
tit <- as.data.frame(Titanic)
tit2d <- aggregate( Freq ~ Class + Survived, data=tit, sum)
getwd()
setwd("..")
library(devtools)
load_all()
alluvial( tit2d[,1:2], freq=tit2d$Freq, xw=0.0, alpha=0.8,
gap.width=0.1, col= "steelblue", border="white",
layer = tit2d$Survived != "Yes" )
alluvial( tit2d[,1:2], freq=tit2d$Freq, xw=0.0, alpha=0.8,
gap.width=0.1, col= "steelblue", border="white",
layer = tit2d$Survived != "Yes", blocks=F )
alluvial( tit2d[,1:2], freq=tit2d$Freq,
hide=tit2d$Freq < 150,
xw=0.0, alpha=0.8,
gap.width=0.1, col= "steelblue", border="white",
layer = tit2d$Survived != "Yes" )
alluvial( tit2d[,1:2], freq=tit2d$Freq,
hide=tit2d$Freq < 150,
xw=0.0, alpha=0.8,
gap.width=0.1, col= "steelblue", border="white",
layer = tit2d$Survived != "Yes",
blocks=F)
tit3d <- aggregate( Freq ~ Class + Sex + Survived, data=tit, sum)
alluvial(tit3d[,1:3], freq=tit3d$Freq, alpha=1, xw=0.2,
col=ifelse( tit3d$Survived == "No", "red", "gray"),
layer = tit3d$Sex != "Female",
border="white")
alluvial(tit3d[,1:3], freq=tit3d$Freq, alpha=1, xw=0.2,
col=ifelse( tit3d$Survived == "No", "red", "gray"),
layer = tit3d$Sex != "Female",
border="white",blocks=F)
alluvial( tit[,1:4], freq=tit$Freq, border=NA,
hide = tit$Freq < quantile(tit$Freq, .50),
col=ifelse( tit$Class == "3rd" & tit$Sex == "Male", "red", "gray") )
alluvial( tit[,1:4], freq=tit$Freq, border=NA,
hide = tit$Freq < quantile(tit$Freq, .50),
col=ifelse( tit$Class == "3rd" & tit$Sex == "Male", "red", "gray"),
blocks=F)
head(tit)
c(TRUE, FALSE, "fred")
if("TRUE") 5 else 7
seq_along(dd)
seq_along(list(a=1,b=2,c=3))
tit <- as.data.frame(Titanic)
load_all()
for (spline in c(TRUE, FALSE)) {
# Possible blocks options
for (blocks in c(TRUE, FALSE, "bookends")) {
# Elaborate alluvial diagram from main examples file
alluvial( tit[, 1:4], freq = tit$Freq, border = NA,
hide = tit$Freq < quantile(tit$Freq, .50),
col = ifelse( tit$Class == "3rd" & tit$Sex == "Male",
"red", "gray" ),
spline = spline, blocks = blocks )
}
}
load_all()
for (spline in c(TRUE, FALSE)) {
# Possible blocks options
for (blocks in c(TRUE, FALSE, "bookends")) {
# Elaborate alluvial diagram from main examples file
alluvial( tit[, 1:4], freq = tit$Freq, border = NA,
hide = tit$Freq < quantile(tit$Freq, .50),
col = ifelse( tit$Class == "3rd" & tit$Sex == "Male",
"red", "gray" ),
spline = spline, blocks = blocks )
}
}
load_all()
for (spline in c(TRUE, FALSE)) {
# Possible blocks options
for (blocks in c(TRUE, FALSE, "bookends")) {
# Elaborate alluvial diagram from main examples file
alluvial( tit[, 1:4], freq = tit$Freq, border = NA,
hide = tit$Freq < quantile(tit$Freq, .50),
col = ifelse( tit$Class == "3rd" & tit$Sex == "Male",
"red", "gray" ),
spline = spline, blocks = blocks )
}
}
load_all()
for (spline in c(TRUE, FALSE)) {
# Possible blocks options
for (blocks in c(TRUE, FALSE, "bookends")) {
# Elaborate alluvial diagram from main examples file
alluvial( tit[, 1:4], freq = tit$Freq, border = NA,
hide = tit$Freq < quantile(tit$Freq, .50),
col = ifelse( tit$Class == "3rd" & tit$Sex == "Male",
"red", "gray" ),
spline = spline, blocks = blocks )
}
}
load_all()
for (spline in c(TRUE, FALSE)) {
# Possible blocks options
for (blocks in c(TRUE, FALSE, "bookends")) {
# Elaborate alluvial diagram from main examples file
alluvial( tit[, 1:4], freq = tit$Freq, border = NA,
hide = tit$Freq < quantile(tit$Freq, .50),
col = ifelse( tit$Class == "3rd" & tit$Sex == "Male",
"red", "gray" ),
spline = spline, blocks = blocks )
}
}
is.logical("bookends")
is.logical(TRUE)
load_all()
for (spline in c(TRUE, FALSE)) {
# Possible blocks options
for (blocks in c(TRUE, FALSE, "bookends")) {
# Elaborate alluvial diagram from main examples file
alluvial( tit[, 1:4], freq = tit$Freq, border = NA,
hide = tit$Freq < quantile(tit$Freq, .50),
col = ifelse( tit$Class == "3rd" & tit$Sex == "Male",
"red", "gray" ),
spline = spline, blocks = blocks )
}
}
head(tit)
freq = tit$Freq
border = NA
hide = tit$Freq < quantile(tit$Freq, .50)
col = ifelse( tit$Class == "3rd" & tit$Sex == "Male",
"red", "gray" )
spline = spline
spline=TRUE
blocks=TRUE
p <- data.frame( ..., freq=freq, col, alpha, border, hide, stringsAsFactors=FALSE)
p <- data.frame( tit[, 1:4], freq=freq, col, alpha, border, hide, stringsAsFactors=FALSE)
alpha=.5
gap.width=.05
xw=.1
cw=.1
p <- data.frame( tit[, 1:4], freq=freq, col, alpha, border, hide, stringsAsFactors=FALSE)
n <- nrow(p)
layer
layer <- 1:n
p$layer <- layer
np <- ncol(p) - 6                    # Number of dimensions
np
d <- p[ , 1:np, drop=FALSE]          # Dimensions dframe
p <- p[ , -c(1:np), drop=FALSE]      # Parameteres dframe
p$freq <- with(p, freq/sum(freq))    # Frequencies (weights)
col <- col2rgb(p$col, alpha=TRUE)
if(!identical(alpha, FALSE)) {
col["alpha", ] <- p$alpha*256
}
p$col <- apply(col, 2, function(x) do.call(rgb, c(as.list(x), maxColorValue = 256)))
isch <- sapply(d, is.character)
d[isch] <- lapply(d[isch], as.factor)
length(blocks)
blocks
blocks <- if (is.logical(blocks))
{
rep(blocks, np)
} else if (blocks == "bookends")
{
c(TRUE, rep(FALSE, np - 2), TRUE)
}
blocks
getp <- function(i, d, f, w=gap.width) {
# Ordering dimension ids for lexicographic sorting
a <- c(i, (1:ncol(d))[-i])
# Order of rows of d starting from i-th dimension
o <- do.call(order, d[a])
# Breakpoints on a dimension
x <- c(0, cumsum(f[o])) * (1-w)
# Stripe coordinates on a dimension
x <- cbind(x[-length(x)], x[-1])
# By how much stripes need to be shifted upwards (gap/max(gap))
gap <- cumsum( c(0L, diff(as.numeric(d[o,i])) != 0) )
mx <- max(gap)
if (mx == 0) mx <- 1
# shifts
gap <- gap / mx * w
# add gap-related shifts to stripe coordinates on dimension i
(x + gap)[order(o),]
}
dd <- lapply(seq_along(d), getp, d=d, f=p$freq)
op <- par(mar=c(2, 1, 1, 1))
plot(NULL, type="n", xlim=c(1-cw, np+cw), ylim=c(0, 1), xaxt="n", yaxt="n",
xaxs="i", yaxs="i", xlab='', ylab='', frame=FALSE)
ind <- rev(order(p$layer)[!hide])
i
i=1
j=1
rm(i,j)
for(i in ind )
{
# For every inter-dimensional segment
for(j in 1:(np-1) )
{
# Draw stripe
xspline( c(j, j, j+xw, j+1-xw, j+1, j+1, j+1-xw, j+xw, j) + rep(c(cw, -cw, cw), c(3, 4, 2)),
c( dd[[j]][i, c(1, 2, 2)], rev(dd[[j+1]][i, c(1, 1, 2, 2)]), dd[[j]][i,c(1, 1)]),
shape = c(0,0,1,1,0,0,1,1,0, 0),
open=FALSE,
col=p$col[i], border=p$border[i])
}
}
j=1
ax <- lapply(split(dd[[j]], d[,j]), range)
blocks[j]
if (blocks[j])
{
for(k in seq_along(ax))
{
rect( j-cw, ax[[k]][1], j+cw, ax[[k]][2] )
}
} else
{
for (i in ind)
{
x <- j + c(-1, 1) * cw
y <- t(dd[[j]][c(i, i), ])
w <- xw * (x[2] - x[1])
xspline(x = c(x[1], x[1], x[1] + w, x[2] - w,
x[2], x[2], x[2] - w, x[1] + w, x[1]),
y = c(y[c(1, 2, 2), 1], y[c(2, 2, 1, 1), 2], y[c(1, 1), 1]),
shape = c(0, 0, 1, 1, 0, 0, 1, 1, 0, 0),
open = FALSE, col = p$col[i], border = p$border[i])
}
}
rm(j)
j=2
seq_along(dd)
j=1
for(k in seq_along(ax))
{
text( j, mean(ax[[k]]), labels=names(ax)[k])
}
seq_along(dd)
blocks[1]
blocks[j]
#' Alluvial diagram
#'
#' Drawing alluvial diagrams also known as parallel set plots.
#'
#' Still under development!
#'
#' @param ... vectors or data frames, all for the same number of observations
#' @param freq numeric, vector of frequencies of the same length as the number of observations
#' @param col vector of colors of the stripes
#' @param border vector of border colors for the stripes
#' @param layer numeric, order of drawing of the stripes
#' @param hide logical, should particular stripe be plotted
#' @param alpha numeric, vector of transparency of the stripes
#' @param gap.width numeric, relative width of inter-category gaps
#' @param xw numeric, the distance from the set axis to the control points of the xspline
#' @param cw numeric, width of the category axis
#' @param spline logical, whether to use splines rather than parallelograms
#' @param blocks logical, whether to use blocks to tie the flows together at each category, versus contiguous ribbons (also admits character value "bookends")
#'
#' @return Nothing
#'
#' @export
#'
#' @example examples/alluvial.R
alluvial <- function( ..., freq,
col="gray", border=0, layer, hide=FALSE, alpha=0.5,
gap.width=0.05, xw=0.1, cw=0.1,
spline = TRUE, blocks = TRUE )
{
# Data and graphical parameters
p <- data.frame( ..., freq=freq, col, alpha, border, hide, stringsAsFactors=FALSE)
n <- nrow(p)
# Layers determine plotting order
if(missing(layer))
{
layer <- 1:n
}
p$layer <- layer
np <- ncol(p) - 6                    # Number of dimensions
d <- p[ , 1:np, drop=FALSE]          # Dimensions dframe
p <- p[ , -c(1:np), drop=FALSE]      # Parameteres dframe
p$freq <- with(p, freq/sum(freq))    # Frequencies (weights)
# Converting colors to hexcodes
col <- col2rgb(p$col, alpha=TRUE)
if(!identical(alpha, FALSE)) {
col["alpha", ] <- p$alpha*256
}
p$col <- apply(col, 2, function(x) do.call(rgb, c(as.list(x), maxColorValue = 256)))
# convert character vectors in data to factors
isch <- sapply(d, is.character)
d[isch] <- lapply(d[isch], as.factor)
# Convert blocks to vector
if (length(blocks) == 1)
{
blocks <- if (is.logical(blocks))
{
rep(blocks, np)
} else if (blocks == "bookends")
{
c(TRUE, rep(FALSE, np - 2), TRUE)
}
}
# Compute endpoints of flows (polygons)
# i = dimension id
# d = data frame of dimensions
# f = weights
# w = gap between categories
getp <- function(i, d, f, w=gap.width) {
# Ordering dimension ids for lexicographic sorting
a <- c(i, (1:ncol(d))[-i])
# Order of rows of d starting from i-th dimension
o <- do.call(order, d[a])
# Breakpoints on a dimension
x <- c(0, cumsum(f[o])) * (1-w)
# Stripe coordinates on a dimension
x <- cbind(x[-length(x)], x[-1])
# By how much stripes need to be shifted upwards (gap/max(gap))
gap <- cumsum( c(0L, diff(as.numeric(d[o,i])) != 0) )
mx <- max(gap)
if (mx == 0) mx <- 1
# shifts
gap <- gap / mx * w
# add gap-related shifts to stripe coordinates on dimension i
(x + gap)[order(o),]
}
# Calculate stripe locations on dimensions: list of data frames. A component
# for a dimension. Data frame contains 'y' locations of stripes.
dd <- lapply(seq_along(d), getp, d=d, f=p$freq)
# Plotting
op <- par(mar=c(2, 1, 1, 1))
plot(NULL, type="n", xlim=c(1-cw, np+cw), ylim=c(0, 1), xaxt="n", yaxt="n",
xaxs="i", yaxs="i", xlab='', ylab='', frame=FALSE)
# For every stripe
ind <- rev(order(p$layer)[!hide])
for(i in ind )
{
# For every inter-dimensional segment
for(j in 1:(np-1) )
{
# Draw stripe
xspline( c(j, j, j+xw, j+1-xw, j+1, j+1, j+1-xw, j+xw, j) + rep(c(cw, -cw, cw), c(3, 4, 2)),
c( dd[[j]][i, c(1, 2, 2)], rev(dd[[j+1]][i, c(1, 1, 2, 2)]), dd[[j]][i,c(1, 1)]),
shape = c(0,0,1,1,0,0,1,1,0, 0),
open=FALSE,
col=p$col[i], border=p$border[i])
}
}
# Category blocks with labels
for(j in seq_along(dd))
{
ax <- lapply(split(dd[[j]], d[,j]), range)
if (blocks[j])
{
for(k in seq_along(ax))
{
rect( j-cw, ax[[k]][1], j+cw, ax[[k]][2] )
}
} else
{
for (i in ind)
{
x <- j + c(-1, 1) * cw
y <- t(dd[[j]][c(i, i), ])
w <- xw * (x[2] - x[1])
xspline(x = c(x[1], x[1], x[1] + w, x[2] - w,
x[2], x[2], x[2] - w, x[1] + w, x[1]),
y = c(y[c(1, 2, 2), 1], y[c(2, 2, 1, 1), 2], y[c(1, 1), 1]),
shape = c(0, 0, 1, 1, 0, 0, 1, 1, 0, 0),
open = FALSE, col = p$col[i], border = p$border[i])
}
}
for(k in seq_along(ax))
{
text( j, mean(ax[[k]]), labels=names(ax)[k])
}
}
# X axis
axis(1, at= rep(c(-cw, cw), ncol(d)) + rep(seq_along(d), each=2),
line=0.5, col="white", col.ticks="black", labels=FALSE)
axis(1, at=seq_along(d), tick=FALSE, labels=names(d))
par(op)
}
# Possible spline options
for (spline in c(TRUE, FALSE)) {
# Possible blocks options
for (blocks in c(TRUE, FALSE, "bookends")) {
# Elaborate alluvial diagram from main examples file
alluvial( tit[, 1:4], freq = tit$Freq, border = NA,
hide = tit$Freq < quantile(tit$Freq, .50),
col = ifelse( tit$Class == "3rd" & tit$Sex == "Male",
"red", "gray" ),
spline = spline, blocks = blocks )
}
}
splie
spline
blocks
as.logical("TRUE")
as.logical("hello")
load_all()
# Possible spline options
for (spline in c(TRUE, FALSE)) {
# Possible blocks options
for (blocks in c(TRUE, FALSE, "bookends")) {
# Elaborate alluvial diagram from main examples file
alluvial( tit[, 1:4], freq = tit$Freq, border = NA,
hide = tit$Freq < quantile(tit$Freq, .50),
col = ifelse( tit$Class == "3rd" & tit$Sex == "Male",
"red", "gray" ),
spline = spline, blocks = blocks )
}
}
rm(list=ls())
tit <- as.data.frame(Titanic)
load_all()
# Possible spline options
for (spline in c(TRUE, FALSE)) {
# Possible blocks options
for (blocks in c(TRUE, FALSE, "bookends")) {
# Elaborate alluvial diagram from main examples file
alluvial( tit[, 1:4], freq = tit$Freq, border = NA,
hide = tit$Freq < quantile(tit$Freq, .50),
col = ifelse( tit$Class == "3rd" & tit$Sex == "Male",
"red", "gray" ),
spline = spline, blocks = blocks )
}
}
rm(list=ls())
tit <- as.data.frame(Titanic)
load_all()
# Possible blocks options
for (blocks in c(TRUE, FALSE, "bookends")) {
# Elaborate alluvial diagram from main examples file
alluvial( tit[, 1:4], freq = tit$Freq, border = NA,
hide = tit$Freq < quantile(tit$Freq, .50),
col = ifelse( tit$Class == "3rd" & tit$Sex == "Male",
"red", "gray" ),
spline = spline, blocks = blocks )
}
tit <- as.data.frame(Titanic)
load_all()
# Possible blocks options
for (blocks in c(TRUE, FALSE, "bookends")) {
# Elaborate alluvial diagram from main examples file
alluvial( tit[, 1:4], freq = tit$Freq, border = NA,
hide = tit$Freq < quantile(tit$Freq, .50),
col = ifelse( tit$Class == "3rd" & tit$Sex == "Male",
"red", "gray" ),
blocks = blocks )
}
